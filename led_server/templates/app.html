<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }

        #canvas {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>

        var triangles = []
        var interval;

        window.addEventListener("load", () => {
            const canvas = document.querySelector("#canvas");
            const ctx = canvas.getContext("2d");
            // Resizing
            canvas.height = window.innerHeight * 0.99;
            canvas.width = window.innerWidth * (1080/1920);

            // RECEIVE AND CONVERT PYTHON DATA TO TRIANGLES
            parse_triangle_data("{{triangle_JSON}}");
            window.interval = setInterval(loop, 50);
        })

        function loop() {
            const canvas = document.querySelector("#canvas");
            const ctx = canvas.getContext("2d");
            // Clear
            ctx.clearRect(0,0,canvas.width,canvas.height);
            // Advance patterns
            advance_pattern();
            // Draw new
            display_triangles(ctx);
        }


        function parse_triangle_data(td) {
            td = td.replace(/&#34;/g, "\"");
            var triangle_list = JSON.parse(td);
            window.triangles = triangle_list;
        }

        function rgb_to_hex(rgb_tuple) {
            var r = Number(rgb_tuple[0]).toString(16);
            var g = Number(rgb_tuple[1]).toString(16);
            var b = Number(rgb_tuple[2]).toString(16);

            return "#" + ((r.length == 1) ? "0" : "") + r + ((g.length == 1) ? "0" : "") + g + ((b.length == 1) ? "0" : "") + b;

        }

        function display_triangles(ctx) {

            // Set up scaling and offset variables
            var x_offset = 0;
            var y_offset = 0;
            var max_x = 0;
            var min_y = 0;
            window.triangles.forEach(triangle => {
                if (triangle["x"] < x_offset) {x_offset = triangle["x"]}
                if (triangle["y"] > y_offset) {y_offset = triangle["y"]}
                if (triangle["x"] > max_x) {max_x = triangle["x"]}
                if (triangle["y"] < min_y) {min_y = triangle["y"]}
            });
            var delta_x = Math.abs(max_x - x_offset);
            var delta_y = Math.abs(min_y - y_offset);

            console.log("dx: " + delta_x);
            console.log("dy: " + delta_y);
            console.log("xoff: " + x_offset + " | max_x: " + max_x);
            console.log("yoff: " + y_offset + " | min_y: " + min_y);
            // Dynamic scaling (kill me)
            var size = 1080 / Math.max((delta_x+1)/2 + ((delta_x%2==1) ? 0.5 : 0), delta_y+1) * 0.9;
            console.log("Scaling: " + size);

            // Draw each triangle
            window.triangles.forEach(t => {
                var rgb_hex = rgb_to_hex(t["next_rgb"]);
                var upside_down = ((Math.abs(t["x"]) + Math.abs(t["y"])) % 2 == 1)
                draw_triangle_to_screen(ctx, t["x"], t["y"], upside_down, size, rgb_hex, false, x_offset*-1, y_offset);
            });
        }


        function advance_pattern() {
            window.triangles.forEach(triangle => {
                switch (triangle["pattern"]) {
                    case "breathe":
                        // # Advance cycle
                        triangle["cycle"] = (triangle["cycle"] + triangle["speed"]) % 512;
                        // # Get the cycle percentage (how far are we into the cycle)
                        var cycle_percentage = triangle["cycle"] / 512;
                        // # How many percent of maximum light are we supposed to give
                        var light_fraction = (Math.sin(cycle_percentage * 2 * Math.PI) / 2) + 0.5;
                        // # With regards to min/max how many ACTUAL percent of light to we need
                        var light_percentage = (light_fraction * (triangle["maximum"] - triangle["minimum"]) + triangle["minimum"]) / 255;

                        // # Apply and return
                        var r = parseInt(triangle["rgb"][0] * light_percentage);
                        var g = parseInt(triangle["rgb"][1] * light_percentage);
                        var b = parseInt(triangle["rgb"][2] * light_percentage);

                        triangle["next_rgb"] = [r,g,b];
                        break;

                    case "rainbow":
                        // # Advance cycle
                        triangle["cycle"] = (triangle["cycle"] + triangle["speed"]) % 768
                        // # Find out where we are in the r cycle, g cycle, and b cycle
                        var cycle_percentages = [
                            ((triangle["cycle"] + 0)    % 768) / 256,
                            ((triangle["cycle"] + 85)   % 768) / 256,
                            ((triangle["cycle"] + 170)  % 768) / 256,
                        ];
                        //  # Calculate percentage of each color needed
                        var rgb_light_percentages = [
                            (Math.sin(cycle_percentages[0] * 2 * Math.PI) / 2 + 0.5),
                            (Math.sin(cycle_percentages[1] * 2 * Math.PI) / 2 + 0.5),
                            (Math.sin(cycle_percentages[2] * 2 * Math.PI) / 2 + 0.5),
                        ];
                        // # Apply to r, g, and, b, then return
                        var next_rgb = [
                            parseInt(triangle["rgb"][0] * rgb_light_percentages[0]),
                            parseInt(triangle["rgb"][1] * rgb_light_percentages[1]),
                            parseInt(triangle["rgb"][2] * rgb_light_percentages[2]),
                        ];

                        triangle["next_rgb"] = next_rgb;
                        break;
                
                    default:
                        triangle["next_rgb"] = triangle["rgb"];
                        break;
                }
            });
        }


        function draw_triangle_to_screen(ctx, x, y, upsidedown, size, color, outlined, x_offset, y_offset) {
            // Set up values
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;
            var stroke_offset = ((outlined) ? 5 : 0);

            var adjusted_x = (x + x_offset) * size * 0.5;
            var adjusted_y = (y_offset - y) * size * 0.866;
            var triangle_height = size * 0.866;

            // Draw
            ctx.beginPath();
            if (upsidedown) {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
            } else {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
            }

            // Check if you want to fill or no
            if (outlined) {
                ctx.stroke();
            } else {
                ctx.fill();
            }
        }

    </script>
    
</body>
</html>