<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #canvas {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>

        var triangles = []

        window.addEventListener("load", () => {
            const canvas = document.querySelector("#canvas");
            const ctx = canvas.getContext("2d");
            // Resizing
            canvas.height = window.innerHeight * 0.9;
            canvas.width = window.innerWidth * 0.9;

            // RECEIVE AND CONVERT PYTHON DATA TO TRIANGLES
            parse_triangle_data("{{triangle_JSON}}");
            display_triangles(ctx);
        })


        function parse_triangle_data(td) {
            td = td.replace(/&#34;/g, "\"");
            var triangle_list = JSON.parse(td);
            window.triangles = triangle_list;
        }

        function rgb_to_hex(rgb_tuple) {
            var r = Number(rgb_tuple[0]).toString(16);
            var g = Number(rgb_tuple[1]).toString(16);
            var b = Number(rgb_tuple[2]).toString(16);

            return "#" + ((r.length == 1) ? "0" : "") + r + ((g.length == 1) ? "0" : "") + g + ((b.length == 1) ? "0" : "") + b;

        }

        function display_triangles(ctx) {
            // TODO: Edit this to be dynamic
            var size = 100;

            window.triangles.forEach(t => {
                var rgb_hex = rgb_to_hex(t["rgb"]);
                var upside_down = ((t["x"] + t["y"]) % 2 == 1)
                draw_triangle_to_screen(ctx, t["x"], t["y"], upside_down, size, rgb_hex, false, 0, 0);
            });
        }


        // function advance_pattern() {
        //     window.triangles.forEach(triangle => {
        //         switch (triangle["pattern"]) {
        //             case :
                        
        //                 break;
                
        //             default:
        //                 break;
        //         }
        //     });
        // }


        function draw_triangle_to_screen(ctx, x, y, upsidedown, size, color, outlined, x_offset, y_offset) {
            // Set up values
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;
            var stroke_offset = ((outlined) ? 5 : 0);

            var adjusted_x = (x + x_offset) * size * 0.5;
            var adjusted_y = (y + y_offset) * size;
            var triangle_height = size * 0.866;

            // Draw
            ctx.beginPath();
            if (upsidedown) {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
            } else {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
            }

            // Check if you want to fill or no
            if (outlined) {
                ctx.stroke();
            } else {
                ctx.fill();
            }
        }

    </script>
    
</body>
</html>