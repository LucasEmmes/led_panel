<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #canvas {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>

        var triangles = []
        var interval;

        window.addEventListener("load", () => {
            const canvas = document.querySelector("#canvas");
            const ctx = canvas.getContext("2d");
            // Resizing
            canvas.height = window.innerHeight * 0.9;
            canvas.width = window.innerWidth * 0.9;

            // RECEIVE AND CONVERT PYTHON DATA TO TRIANGLES
            parse_triangle_data("{{triangle_JSON}}");
            window.interval = setInterval(loop, 10);
        })

        function loop() {
            const canvas = document.querySelector("#canvas");
            const ctx = canvas.getContext("2d");
            // Clear
            ctx.clearRect(0,0,canvas.width,canvas.height);
            // Advance patterns
            advance_pattern();
            // Draw new
            display_triangles(ctx);
        }


        function parse_triangle_data(td) {
            td = td.replace(/&#34;/g, "\"");
            var triangle_list = JSON.parse(td);
            window.triangles = triangle_list;
        }

        function rgb_to_hex(rgb_tuple) {
            var r = Number(rgb_tuple[0]).toString(16);
            var g = Number(rgb_tuple[1]).toString(16);
            var b = Number(rgb_tuple[2]).toString(16);

            return "#" + ((r.length == 1) ? "0" : "") + r + ((g.length == 1) ? "0" : "") + g + ((b.length == 1) ? "0" : "") + b;

        }

        function display_triangles(ctx) {
            // TODO: Edit this to be dynamic
            var size = 100;

            window.triangles.forEach(t => {
                var rgb_hex = rgb_to_hex(t["next_rgb"]);
                var upside_down = ((t["x"] + t["y"]) % 2 == 1)
                draw_triangle_to_screen(ctx, t["x"], t["y"], upside_down, size, rgb_hex, false, 0, 0);
            });
        }


        function advance_pattern() {
            window.triangles.forEach(triangle => {
                switch (triangle["pattern"]) {
                    case "breathe":
                        // # Advance cycle
                        triangle["cycle"] = (triangle["cycle"] + triangle["speed"]) % 512;
                        // # Get the cycle percentage (how far are we into the cycle)
                        var cycle_percentage = triangle["cycle"] / 512;
                        // # How many percent of maximum light are we supposed to give
                        var light_fraction = (Math.sin(cycle_percentage * 2 * Math.PI) / 2) + 0.5;
                        // # With regards to min/max how many ACTUAL percent of light to we need
                        var light_percentage = (light_fraction * (triangle["maximum"] - triangle["minimum"]) + triangle["minimum"]) / 255;

                        // # Apply and return
                        var r = parseInt(triangle["rgb"][0] * light_percentage);
                        var g = parseInt(triangle["rgb"][1] * light_percentage);
                        var b = parseInt(triangle["rgb"][2] * light_percentage);

                        triangle["next_rgb"] = [r,g,b];
                        break;
                
                    default:
                        triangle["next_rgb"] = triangle["rgb"];
                        break;
                }
            });
        }


        function draw_triangle_to_screen(ctx, x, y, upsidedown, size, color, outlined, x_offset, y_offset) {
            // Set up values
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 5;
            var stroke_offset = ((outlined) ? 5 : 0);

            var adjusted_x = (x + x_offset) * size * 0.5;
            var adjusted_y = (y + y_offset) * size;
            var triangle_height = size * 0.866;

            // Draw
            ctx.beginPath();
            if (upsidedown) {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y+stroke_offset);
            } else {
                ctx.moveTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x-stroke_offset+size,   adjusted_y-stroke_offset+triangle_height);
                ctx.lineTo(adjusted_x+size*0.5,             adjusted_y+stroke_offset);
                ctx.lineTo(adjusted_x+stroke_offset,        adjusted_y-stroke_offset+triangle_height);
            }

            // Check if you want to fill or no
            if (outlined) {
                ctx.stroke();
            } else {
                ctx.fill();
            }
        }

    </script>
    
</body>
</html>